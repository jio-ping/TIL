## 메모리 관리

### 📌 프로세스의 동작

: 프로그램 카운터를 참조해 수행될 명령을 메모리에서 읽어 CPU로 수행하는 것

#### 📎 기억장치 계층구조

<img src ="https://github.com/user-attachments/assets/6d97ea80-3223-43ea-ad28-512261c042a6" width="400px">

### 📌 단일 프로그래밍

: 하나의 프로세스만 메모리를 전용으로 사용하는 것. 프로세스는 하나의 연속된 블록으로 메모리에 할당함

#### 문제점

1. 메모리의 용량을 초과하는 프로세스는 실행 못함
2. 메모리 낭비 심함
3. 주변장치 등 자원의 낭비 심함

### 📌 다중프로그래밍

: 여러 개의 프로세스가 메모리에 동시에 적재되는 것. CPU 연산과 입출력을 동시에 함으로써 CPU 이용도와 시스템 처리량 증가

#### 📎 메모리 분할

: 여러 프로세스를 메모리에 적재하기 위해 고안된 방법. 하나의 분할에 하나의 프로세스가 적재되는 방식

1. 고정분할</br>
   : 메모리를 여러개의 고정된 크기의 영역으로 분할
   - 문제점: 프로세스의 크기가 적재된 분할영역의 크기보다 작아서 분할영역 내에 남게 되는 메모리 발생 </br>
     ➡️ 수행할 프롯세스의 크기를 미리 알고 그에 맞춰 고정분할을 해야하나 ,현실적이지 않음

- 프로세스 배치 방법 1</br>
  <img src ="https://github.com/user-attachments/assets/fe739fe8-0ef5-449c-a046-d7b701138a8d" width="400px"></br>
  : 분할영역마다 큐를 두고 큐에 들어온 프로세스는 해당 분할영역에만 적재</br>
  ➡️ 절대번역 및 적재-> 효율성 낮음

- 프로세스 배치 방법 2
  <img src="https://github.com/user-attachments/assets/62bd35dd-b71d-423e-856c-d64d537d834c" width="400px"></br>
  : 하나의 큐만 두고 큐에 들어온 프로세스는 어느 분할영역에든 적재. </br>
  ➡️ 재배치 가능 번역 및 적재 -> 복잡함

2. 동적분할
   : 메모리의 분할경계가 고정되지 않음. 각 프로세스에 필요한 만큼의 메모리만 할당</br>
   - 문제점: 외부단편화(:메모리의 할당과 반환이 반복됨에 따라 작은 크기의 공백이 메모리 공간에 흩어져 생김 )</br>➡️ 통합, 집약

- 통합: 인접된 공백을 더 큰 하나의 공백으로 만들어 외부 단편화 해결
  <img src="https://github.com/user-attachments/assets/b609c480-5432-4557-ab86-aa8059c5ba40" width="200px"></br>
- 집약: 메모리 내의 모든 공백을 하나로 모아 외부 단편화 해결 </br>
  <img src="https://github.com/user-attachments/assets/a47a9215-de8a-4f49-ad40-37a8d990df2a" width="200px"></br>
  ➡️ 프로세스를 복사해 매번 옮겨줘야 해서 항상 실행하긴 부담
- 메모리 보호: 프로세스가 다른 할당영역을 침범하지 않게 하는 것 </br>
  ➡️ 하한-상한 또는 하한-크기 레지스터 쌍으로 제한(이 제한 넘어 호출시 시스템 호출 이용)

### 📌 메모리 배치기법

: 동적 분할 다중프로그래밍에서 새로 반입된 프로그램이나 데이터를 메모리의 어느 위치에 배치할 것인가를 결정

#### 📎 최초적합

<img src="https://github.com/user-attachments/assets/a4e175ac-6e50-40e5-a6f1-4b0a574abe82" width="400px"></br>
: 프로세스가 적재될 수 있는 빈 공간 중 가장 먼저 발견되는 곳 할당

#### 📎 후속적합

<img src="https://github.com/user-attachments/assets/75ae79f8-16f1-4997-a4ed-c3a81bdf9a2a" width="400px"></br>
: 최초 적합의 변형, 이전에 탐색이 끝난 그 다음의 부분부터 시작해 사용 가능한 빈 공간 중에서 가장 먼저 발견되는 곳을 할당

#### 📎 최적적합

<img src="https://github.com/user-attachments/assets/edac34fc-68cf-437a-aaf5-e84bd75ce92a" width="400px">
: 필요한 공간을 제공할 수 잇는 빈공간 중 가장 작은 곳을 선택하여 할당 </br>
➡️ 큰 빈공간을 최대한 많이 남겨 놓기 위한 방법

#### 📎 최악적합

<img src="https://github.com/user-attachments/assets/b02b73bd-f3b8-4466-a0e1-8868da2b2a49" width="400px"></br>
: 필요한 공간을 제공할 수 있는 빈 공간 중 가장 큰 곳을 선택해 할당</br>
➡️ 작은 자투리가 남아 사용되지 못하는 공간이 발생하는 것을 최고화하기 위한 방법
