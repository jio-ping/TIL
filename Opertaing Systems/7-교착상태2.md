<details> 
<summary >
📕  용어 정의</summary>
<b>📍 안전상태</b>: 교착상태를 회피하면서 각 프로세스에 그들의 최대 요구량 까지 빠짐없이 자원을 할당할 수 있는 상태, 안전순서열이 존재하는 경우</br></br>
<b>📍 불안전상태</b>: 안전순서열이 존재하지 않는 경우</br></br>
</details>

### 📌 안전순서열

: 순서 있는 프로세스의 집합 <br/>
각 pi에 대해 p<sub>i</sub>가 추가로 요구할 수 있는 자원의 양이 현재 가용상태의 자원으로 충당되거나 혹은 여기에 p<sub>j</sub>(단,j가 i보다 큼)에 할당된 자원까지 포함하여 충당가능한 경우

### 📌 교착상태 회피(=교착상태가 일어날지 미리 계산해서 피하기 )

: 교착상태는 <b>불완전상태</b>에서만 발생가능 </br>
프로세스가 가용상태의 자원을 요구하더라도 프로세스는 대기상태가 될 수 있음</br>
➡️ 자원이용율은 낮아질 수 있음

### 📌 교착상태 회피 알고리즘

#### 📎 각 자원의 단위자원이 하나밖에 없는 경우(변형된 자원할당 그래프)

: 각 자원이 한 개씩만 있는 경우(ex. 프린트 한 대, 스캐너 한 대)
<img src="https://github.com/user-attachments/assets/bed2b90d-d53c-4e92-9432-96edbdb9d96a" width="200px"></br>

| 간선종류 | 의미                          | 모양 |
| -------- | ----------------------------- | ---- |
| 선언간선 | 프로세스가 미래에 요청할 자원 | 점선 |
| 요구간선 | 실제 자원을 요청한 상태       | 실선 |
| 할당간선 | 자원이 프로세스에 할당됨      | →    |

- 자원 정점에 표시하던 단위자원의 개수를 제거
- 선언간선(p<sub>i</sub>,r<sub>j</sub>)추가(요구간선과 구분을 위해 점선으로 표시) </br>
  ➡️ 앞으로 프로세스 p<sub>i</sub>가 자원 r<sub>j</sub>를 요구

1. 선언간선으로 추후 요청할 자원 미리 표시
2. 자원을 진짜 요청받으면 해당 선언 간선을 요구간선으로 변경
3. 요구간선을 할당간선으로 변환해도 사이클이 생기지 않는 경우에만 자원을 할당하고 할당간선으로 변환(➡️ 자원을 안전히 줄 수 있음)

<details>
<summary>example</summary>
<img src="https://github.com/user-attachments/assets/ddf3067b-0f4c-4d90-8f7a-ce03866406fc" width="400px"></br>

1. p₁이 r₂를 요구할때

- r₁은 이미 p₁에 할당돼 있음
- r₂는 아직 할당되지 않은 상태에서 p₁이 r₂를 요구 </br>
  ➡️ 사이클 생기지 않음

2.  p₂가 r₂를 요구할 때

- r₁은 이미 p₁에 할당돼 있음
- p₂는 r₂를 요청 & 할당했다 가정
- p₁은 r₂를 기다림 -> r₂는 p₂가 가지고 있음
- p₂는 r₁을 요청 -> r₁은 p₁이 갖고있음</br>
  ➡️p₁ → r₂ → p₂ → r₁ → p₁

</details>

#### 📎 각 자원의 단위자원이 여러 개일수 있는 경우(은행원 알고리즘)

: 자원을 요구받으면 그 자원을 할당해주고 난 후의 상태를 미리 계산해 그것이 안전상태인지 확인

- 은행원 알고리즘 : 이 자원 줘도 돌려받을 수 있는지 계산

| 변수   | 역할          |
| ------ | ------------- |
| MAXi   | Pi의 최대요구 |
| ALLOCi | Pi의 할당자원 |
| NEED   | Pi의 추가요구 |
| AVAIL  | 가용자원      |

1. 프로세스가 자원 요청
2. 요청을 줬다고 가정한 뒤, 가용자원에서 요청량만큼 빼고 프로세스에 자원을 준 상태로 시뮬레이션
3. 모든 프로세스가 무사히 종료 가능한 순서가 있으면 안전상태 : 요청 수락🙆‍♀️ | 그렇지 않으면 교착상태일 수 있으므로 요청 거절 🙅‍♀️

<details><summary>example</summary>
<img src="https://github.com/user-attachments/assets/8a65aa77-52ec-4dfa-8b1a-adbd9503fc5c" widht="500px"></br>
</details>

### 📌 교착상태 탐지(Soshani와 Coffman 알고리즘)

- 시간복잡도: O(<sub>mn</sub><sup>2</sup>) m: 자원종류 n:프로세스수
- 알고리즘 수행 시점
  1. 즉시 받아들일 수 없는 자원 요구가 있을 때
  2. 정해진 시간간격
  3. CPU 효율이 일정수준 이하로 떨어질 때

### 📌 교착상태 복구

: 교착상태가 탐지되면 복구조치

- 복구의 주체
  - 오퍼레이터: 수작업으로 복구
  - 운영체제: 자동으로 복구
- 복구방법
  - 교착상태 프로세스를 종료
    1. 모든 교착상태 프로세스를 종료</br>
       단점: 진행했던 비용에 대한 복원비용이 큼
    2. 사이클이 제거될 때까지 교착상태 프로세스를 하나씩 종료</br>
       단점: 종료대상을 선택하기 위한 비용, 매 프로세스 종료 후 교착상태 재확인을 위한 비용
  - 교착상태 프로세스가 할당받은 자원을 해제
    - 사이클이 제거될 때까지 할당된 자원을 단게적으로 선점하여 다른 프로세스들에 할당
    - 프로세스와 자원 선택 기준 :프로세스 진척도, 사용중인 자원의 수
    - 프로세스의 복귀 시점도 제반 요소를 고려해 결정
    - 기아 사태에 빠지지 않도록 프로세스 선택 시 복구 횟수 고려
