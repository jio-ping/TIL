## 프로세스 스케줄링

: 여러 가지 작업의 처리 순서를 결정하는 것

<details> 
<summary >
📕  용어 정의</summary>
<b>📍 처리량(throughput)</b>: 주어진 시간에 처리한 프로세스 수</br></br>
<b>📍 반환시간(turnaround time)</b>: 프로세스 생성 시점부터 종료 시점까지의 소요시간</br></br>
<b>📍 응답시간(response time)</b>: 요청한 시점부터 반응이 시작되는 시점까지의 소요시간</br></br>
<b>📍 대기시간(waiting time)</b>: 프로세스가 종료될 때까지 준비 큐에서 기다린 시간의 합</br></br>
<img src="https://github.com/user-attachments/assets/a72a1e98-262f-4b18-b295-4bcd668021a4" width="400px"></br>
<b>📍문맥교환(context switching)</b>: CPU가 현재 실행 중인 프로세스를 다른 프로세스로 전환할 때 발생하는 과정. CPU가 현재 실행중인 프로세스 문맥을 PCB에 저장하고 다른 프로세스의 PCB로부터 문맥 복원</br></br>

</details>

### 📌 스케줄링 단계

<img width="400px" src="https://github.com/user-attachments/assets/6ae6aed6-07ce-4f68-ae4c-fff7125ecd36"></br>

1. 상위 단계 스케줄링 (high-level scheduling,장기 스케줄링)</br>
   : 시스템에 들어와 작업큐에 있는 작업을 선택해 프로세스를 생성해 준비 큐에 전달하는 역할 <br/>
   시스템 자원을 효율적으로 이용할 수 있도록 함 </br>
2. 중간 단계 스케줄링(Mid-level scheduling) </br>
   : 프로세스를 일시적으로 메모리에서 제거하여 중지시키거나 중지된 프로세스에 다시 메모리를 할당해 시스템에 대한 단기적 부하 조절</br>
3. 하위 단계 스케줄링 (,단기 스케줄링)</br>
   : 준비큐에 있는 프로세스를 선택하여 사용가능한 cpu를 할당하는 역할</br>
   수행주체 : 디스패처

### 📌 스케줄링의 목표

- 공정성:모든 프로세스가 적정수준에서 cpu 작업을 할 수 있게 함
- 균형성:시스템의 자원들이 충분히 활용될 수 있게 함

#### 📎 운영체제 유형에 따른 스케줄링 목표

- 일괄처리 운영체제: 처리량의 극대화, 반환시간의 최소화, CPU활용의 극대화
- 시분할 운영체제: 빠른 응답시간과 과다한 대기시간방비
- 실시간 운영체제: 처리기한 준수

### 📌 스케줄링 정책

1. 선점 스케줄링 : 실행중 프로세스에 인터럽트 걸어 다른 프로세스에 CPU할당(시분할, 실시간 운영체제에 적합). 하지만 문맥교환에 따른 오버헤드가 발생
2. 비선점 스케줄링: 실행중 프로세스를 바로 준비상태로 전이시킬 수 없는 스케줄링 방식

### 📌 스케줄링 평가기준

- 평균대기시간: 프로세스 수행 완료까지 준비큐에서 기다리는 시간 합의 평균값
- 평균반환시간: 프로세스 생성시점부터 수행완료 시점까지의 소요시간의 평균값

## 스케줄링 알고리즘

### 📌 FCFS 스케줄링

: 준비큐에 도착한 순서대로 디스패치되며 프로세스가 CPU를 차지하면 프로세스 완료된 후 다음 프로세스가 차지 ➡️ <b>비선점</b>

- 장점: 가장 간단
- 단점
  1. 짧은 프로세스가 긴 프로세스 기다리거나 중요 프로세스가 나중에 수행 ➡️ 시분할, 실시간 OS 부적합
  2. 프로세스 도착순서 따라 평균 반환시간 크게 변함

<img src="https://github.com/user-attachments/assets/242a0cb5-0849-4b4a-9ed6-93a2fb4b2d90" width="400px">

### 📌 SJF 스케줄링

: 준비큐에서 기다리는 프로세스 중 실행시간이 가장 짧다고 예상되는 것을 먼저 디스패치해 실행하는 <b>비선점</b> 방식의 알고리즘</br>

- 장점: 일괄처리 환경에서 구현 쉬움
- 단점
  1. 실제로는 먼저 처리할 프로세스의 CPU 시간을 예상하지 못함
  2. 새로 들어온 짧은 프로세스가 긴 프로세스를 기다리거나 중간 프로세스가 나중에 수행될 수도 ➡️ 시분할, 실시간 OS 부적합

<img src="https://github.com/user-attachments/assets/a7786786-6c45-490b-bffc-b2830aaa8992" width="400px">

### 📌 SRT 스케줄링

: SJF 알고리즘의 <b>선점</b> 방식으로 준비 큐에서 기다리는 프로세스 중 남은 실행시간이 가장 짧다고 예상되는 것을 먼저 디스패치 하여 실행하는 스케줄링 알고리즘</br>
준비큐에서 새로 들어온 프로세스의 예상 실행시간이 실행중인 프로세스의 남은 실행시간보다 짧다면 새로 들어온 프로세스를 디스패치

- 장점: SJF보다 평균 대기/반환시간이 효율적임
- 단점
  1. 실제로는 프로세스의 CPU시간 예상 불가
  2. 각 프로세스의 실행시간 추적, 선점을 위한 문맥교환보다 SJF보다 오버헤드가 큼

<img src="https://github.com/user-attachments/assets/1134953e-9d1b-4dc1-9726-e4dfdce8798d" width="400px">

### 📌 RR 스케줄링

: 도착한 순서대로 프로세스를 디스패치하지만 정해진 시간 할당량에 의해 실행을 제한, 시간 할당량 안에 종료하지 못하면 준비 큐의 마지막에 들어감 ➡️<b>선점</b>방식

- 장점: CPU 독점 않고 공정이용 (시분할 OS적합)
- 단점
  1. 시간할당량이 너무 크면 FCFS와 동일
  2. 시간할당량이 너무 적으면 문맥교환이 많이 일어나 오버헤드가 많이 발생

<img src="https://github.com/user-attachments/assets/684195ad-af19-4c1c-975f-d5702c3ebfaa" width="400px">

### 📌 HRN 스케줄링

: 준비큐에서 기다리는 프로세스 중 응답비율이 가장 큰 것을 먼저 디스패치해 실행하는 <b>비선점</b>방식</br>

$$응답비율 = \frac{대기시간 + 예상실행시간}{예상실행시간} = \frac{대기시간}{예상실행시간} + 1$$
➡️응답비율은 예상실행시간이 짧을수록, 그리고 대기시간이 길수록 커짐

- 장점 : SJF 스케줄링 단점 보완(예상시간이 긴 프로세스도 오래대기시 응답비율이 커져 짧은 프로세스보다 먼저 디스패치 될 수 있음)
- 단점 : 실제로는 프로세스 CPU 예상시간 예측 x

<img src="https://github.com/user-attachments/assets/95063491-2af4-4f55-9b54-e5e97e4b1eac" width="400px">

### 📌 다단계 피드백 큐 스케줄링

: 입출력 중심인 프로세스와 연산 중심인 프로세스의 특성에 따라 서로 다른 시간 할당량을 부여하는 <b>선점</b>방식 스케줄링 방식</br>
➡️ I/O 위주 프로세스는 높은 우선권 유지 연산 위주의 프로세스는 낮은 우선권이지만 긴 시간 할당량
