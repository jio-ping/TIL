### 📌 병행프로세스의 생산자-소비자

<img src="https://github.com/user-attachments/assets/5e3ed2f9-9f8b-44af-8bae-576fd9fcfa06" width="400px"></br>
➡️ 생산자와 소비자가 독립적 작용하지만 버퍼를 공유하며 사용함

- 버퍼: 데이터 임시 저장
- 생산자: 데이터를 넣는 프로세스
- 소비자: 데이터를 꺼내는 프로세스

#### 📎 생산자 - 소비자 문제 조건

1. 버퍼에 여러 프로세스가 동시에 접근할 수 없음

- 버퍼에 데이터를 넣는 동안 데이터를 꺼낼 수 없음
- 버퍼에서 데이터를 꺼내는 동안에는 데이터를 넣을 수 없음</br>
  ➡️ <b>상호베재 필요 </b></br>

2. 버퍼의 크기가 유한

- 버퍼가 가득 찬 경우 생산자는 대기
- 버퍼가 빈 경우 소비자는 대기</br>
  ➡️ <b>동기화 필요 </b></br>

#### 📎 세마포어를 이용한 해결

| 세마포어 이름 | 초기값   | 의미                |
| ------------- | -------- | ------------------- |
| empty         | 버퍼크기 | 남은 빈 공간 수     |
| full          | 0        | 채워진 공간 수      |
| mutex         | 1        | 버퍼 자체 접근 보호 |

- 생산자의 코드

```c
while (true){
  데이터 생산
  P(empty) // 빈 공간 있는지 확인 (없으면 대기)
  P(mutex) // 버퍼 접근 락
  버퍼에 데이터를 넣음
  V(mutex) // 버퍼 락 해제
  V(full) // 채운 공간 수 증가 (소비자에게 신호)
}
```

- 소비자의 코드

```c
while(true){
  P(full) // 채워진 공간이 있는지 확인(없으면 대기)
  P(mutex) // 버퍼 접근 락
  버퍼에서 데이터를 꺼냄
  V(mutex) // 버퍼 락 해제
  V(empty) // 빈 공간 수 증가( 생산자에게 신호 )
}
```

<details><summary>example</summary>
<img width="450px" src="https://github.com/user-attachments/assets/da59cc85-53eb-4efe-98f2-ebd23161af12">

</details>

### 📌 판독기 - 기록기 문제

<img src ="https://github.com/user-attachments/assets/e16ce8fa-5f32-4352-b05e-9645ba83acae" width="400px"></br>

- 판독기 : 데이터를 읽는 프로세스 (공유자원에 영향 X, 그냥 읽어옴)
- 기록기 : 데이터를 쓰는 프로세스 (공유자원에 데이터를 쓰는 역할)</br>
  ➡️ 생산자-소비자 문제는 공유자원에 영향을 미치나 판독자-기록자는 기록만 공유자원에 영향을 미침

#### 📎 생산자 - 소비자 문제 조건

1. 하나의 기록기가 데이터를 쓰는 동안엔 기록기/판독기 접근 ❌

- 공유자원에 데이터를 쓰는 동안에 누구도 접근할 수 없음
- 공유자원에서 데이터를 읽는 동안에는 데이터를 쓸 수 없음</br>
  ➡️ 상호배제 필요 </br>

2. 여러 판독기는 동시에 공유자원에서 데이터를 읽을 수 있음

- 판독기가 읽는 중 새로운 판독기 읽기 가능
- 판독기가 읽는 중 기록기는 대기 </br>
  ➡️ 새로운 판독기가 읽기 시도는 가능할수도.. 불가능할수도...

#### 📎 제 1 판독기-기록기 문제( 판독기 우선순위 )

: 새로운 판독기는 즉시 공유자원에 접근 가능 </br>
➡️ 기록기의 기아상태 유발 가능

| 세마포어/변수 이름 | 의미                                 | 초기값 |
| ------------------ | ------------------------------------ | ------ |
| mutex              | 세마포어, rcount를 보호()            | 1      |
| wrt                | 세마포어, 자원 접근 제어 (쓰기용 락) | 1      |
| rcount             | 일반변수, 현재 읽고 있는 판독기의 수 | 0      |

- 기록기 코드

```c
 P(wrt)
 공유자원에 쓰기
 V(wrt)
```

➡️ 자원을 독점적으로 사용, 판독기가 하나라도 있으면 대기</br>

- 판독기 코드

```c
P(mutex)
rcount = rcount + 1
if(rcount == 1) P(wrt) // 첫번째 판독기가 자원 잠금
V(mutex)
공유자원에서 읽기
P(mutex)
rcount = rcount - 1
if(rcount == 0 ) V(wrt) // 마지막 판독기가 자원 해제
V(mutex)

```

➡️ 읽는 사람 수를 세면서 첫 번째 판독기만 자원에 대한 락을 걸고, 마지막이 나가면 락 풀기

<details><summary>example</summary>
<img width="450px" src="https://github.com/user-attachments/assets/2df8f190-89b6-4f7c-a790-0b3590b79ccd">

</details>

#### 📎 제 2 판독기-기록기 문제(기록기에 우선순위)

: 대기 중인 기록기가 있다면 새로운 판독기는 공유자원에 접근 불가능 </br>
➡️ 판독기의 병행성이 떨어짐, 판독기의 기아상태 유발

| 세마포어 이름 | 역할                                             | 초기값 |
| ------------- | ------------------------------------------------ | ------ |
| mutex1        | rcount 보호용                                    | 1      |
| mutex2        | wcount 보호용                                    | 1      |
| mutex3        | 판독기 입장 직렬화용 (race condition 방지)       | 1      |
| rd            | 기록기 입장 제어 세마포어(판독기 먼저 입장 막음) | 1      |
| wrt           | 공유자원 보호 세마포어                           | 1      |
| rcount        | 현재 읽고 있는 판독기 수                         | 0      |
| wcount        | 현재 대기 or 작업중인 기록기수                   | 0      |

- 기록기의 코드

```c
P(mutex2)
wcount = wcount + 1
if(wcount == 1) P(rd) // 첫번째 기록기 (판독기 입장 막음)
V(mutex2)

P(wrt) // 공유 자원 잠금 -> 쓰기
공유자원에 쓰기
V(wrt)

P(mutex2)
wcount = wcount - 1
if(wcount == 0) V(rd) // 마지막 기록기 (판독기 입장 허용)
V(mutex2)
```

➡️ 기록기가 처음 도착하면 rd 잠가서 새 판독기 입장 막음, 쓰기 완료 후 wcount 줄이고, 마지막 기록기면 다시 판독기 허용</br>

- 판독기의 코드

```c
P(mutex3) // 판독기 진입 순서 보장
P(rd) // 기록기 있으면 대기
P(mutex1)
rcount = rcount + 1
if(rcount == 1) P(wrt) // 첫 판독기 -> 자원 잠금 (기록기 막기)
V(mutex1)
V(rd) // 바로 다음 판독기 입장 가능
V(mutex3)

공유자원에서 읽기

P(mutex1)
rcount = rcount - 1
if(rcount == 0) V(wrt) // 마지막 판독기 (자원해제)
V(mutex)
```

➡️ 판독기는 기록기 없을때만 입장가능(rd 잠기면 못 들어옴), 여러 판독기 동시에 읽기 가능함, 마지막 판독기 나가면 wrt 해제 (다시 기록기 사용 가능)

### 📌 프로세스간 통신(IPC, InterProcess Communication)

: 병행 프로세스가 데이터를 서로 공유하는 방법 공유 메모리 방법, 메시지 전달방법이 있음 </br>
➡️ 완전 독립적인것은 아니며, 공유메모리와 메시지전달 함께 사용 가능
</br>

#### 📎 공유 메모리 방법

<img width="300px" src= "https://github.com/user-attachments/assets/5f9bfe3d-de5f-4981-afd5-386f6272747c"></br>

: 협력 프로세스가 동일한 변수를 사용 </br>

- 동일한 변수: 공유자원인 메모리 공간 사용</br>
- 예: 생산자-소비자 문제의 유한버퍼, 판독기-기록기 문제의 고유자원
- 대량 데이터 교환: 고속 통신 가능
- 통신상 문제는 프로그래머 해결

#### 📎 메시지 전달 방법

<img width="300px" src= "https://github.com/user-attachments/assets/45260c53-4cb1-415d-82bc-7465e1318e40"></br>
: 협력 프로세스가 메시지를 주고받음 시스템 호출 : send(), receive()</br>

- 소량 데이터교환에 적합
- 통신상 문제는 운영체제가 해결
- 메시지 전달방법의 논리적 구조</br>
  통신링크 : 메시지가 지나다니는 통로
  1. 통신링크의 용량
     - 무한 : 송신자는 대기 없음
     - 유한 : 송신자는 큐가 가득차면 대기
     - 0 : 송신자는 수신자가 메시지를 받을 수 있을때까지 대기
  2. 직접 통신</br>
     <img src ="https://github.com/user-attachments/assets/e8782960-ef2c-4440-9b44-4aaa5ab46423" width="300px"> </br>
     : 오직 하나의 통신링크가 자동설정되며 두 프로세스 사이에만 연관, 통신 링크는 양방향
     - 대칭형 주소지정</br>
       <img src ="https://github.com/user-attachments/assets/8000af92-b4fb-4b89-b96a-b3eab346eac6" width="400px">
     - 비대칭형 주소지정</br>
       <img src ="https://github.com/user-attachments/assets/eed0be2f-b598-4d8e-8143-e2e89c58586f" width="400px"></br>
       : 수신자가 여러 송신자와 통신 링크를 갖는 경우 </br>
  3. 간접 통신</br>
     : 프로세스 사이에 둔 우편함을 통해 메시지 전달. 하나의 통신링크가 여러 프로세스와 연관 가능하고 통신링크는 단방향 또는 양방향
     - 우편함이 수신 프로세스에 소속</br>
       <img src="https://github.com/user-attachments/assets/32180ce3-677b-4a29-877f-7927783e7236" width="400px"></br>
       ➡️ 수신자는 하나, 통신링크는 단방향, 수신프로세스 종료시 우편함 사라짐
     - 우편함이 운영체제에 소속</br>
       <img src="https://github.com/user-attachments/assets/a38608ca-f625-4bd9-9347-d88d2f6e0384" width="400px"></br>
       ➡️ 수신자 여럿, 한 순간에 하나의 수신자만 가능, 운영체제가 수신자 관리, 통신링크는 양방향
